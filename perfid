#!/usr/bin/env bash
# perfid — Orchestrate 7 Claude agents playing Diplomacy with GPG encryption.
#
# Game data lives in $PERFID_GAMES_DIR/<game-id>/ (default: perfid-games/).
# Each agent runs in a Docker sandbox with its own GPG keyring.
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
GAMES_DIR="${PERFID_GAMES_DIR:-perfid-games}"
NEGOTIATION_ROUNDS="${PERFID_NEGOTIATION_ROUNDS:-3}"

POWERS=(Austria England France Germany Italy Russia Turkey)

lowercase() { printf '%s' "$1" | tr '[:upper:]' '[:lower:]'; }

# Wait for background agent PIDs and report failures.
# Usage: wait_agents "${pids[@]}" -- "${powers[@]}"
wait_agents() {
  local pids=() powers=() sep=false
  for arg in "$@"; do
    if [[ "$arg" == "--" ]]; then
      sep=true; continue
    fi
    if $sep; then
      powers+=("$arg")
    else
      pids+=("$arg")
    fi
  done
  local i failures=0
  for i in "${!pids[@]}"; do
    wait "${pids[$i]}" 2>/dev/null || {
      echo "    Warning: ${powers[$i]} failed" >&2
      failures=$((failures + 1))
    }
  done
  return 0
}

usage() {
  cat <<'USAGE'
Usage: perfid <command> <game-id>

Commands:
  new       <game-id>     Create game, 7 agent sandboxes, and GM keys
  bootstrap <game-id>     Agents generate GPG keys and publish pub keys
  play      <game-id>     Main loop: negotiate → orders → adjudicate
  status    <game-id>     Print current standings
  destroy   <game-id>     Tear down agent sandboxes
USAGE
  exit 1
}

[[ $# -eq 0 ]] && usage
cmd=$1; shift

require_game_id() {
  if [[ $# -lt 1 ]] || [[ -z "$1" ]]; then
    echo "Usage: perfid $cmd <game-id>" >&2
    exit 1
  fi
  echo "$1"
}

game_dir() {
  echo "$GAMES_DIR/$1"
}

require_game_exists() {
  local gd
  gd=$(game_dir "$1")
  if [[ ! -f "$gd/state.json" ]]; then
    echo "Error: game '$1' not found at $gd" >&2
    exit 1
  fi
  echo "$gd"
}

case "$cmd" in
  new)
    game_id=$(require_game_id "$@")
    gd=$(game_dir "$game_id")

    if [[ -d "$gd" ]]; then
      echo "Error: game directory $gd already exists." >&2
      exit 1
    fi

    echo "Creating game '$game_id'..."

    # Initialize game state and message directories
    python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import new_game
from message_router import init_message_dirs

state = new_game('$game_id', '$gd')
init_message_dirs('$gd', state['units'].keys())
print(f\"Game state initialized: {state['year']} {state['phase']}\")
"

    # Create pubkeys, orders, and notes directories
    mkdir -p "$gd/pubkeys" "$gd/orders" "$gd/notes"

    # Generate GM GPG key
    gm_gpg="$gd/gm-gpg"
    mkdir -p "$gm_gpg"
    chmod 700 "$gm_gpg"
    gpg --batch --homedir "$gm_gpg" --gen-key <<KEYEOF
Key-Type: RSA
Key-Length: 2048
Name-Real: GM
Name-Email: gm@perfid.local
Expire-Date: 0
%no-protection
%commit
KEYEOF
    gpg --homedir "$gm_gpg" --armor --export gm@perfid.local \
      > "$gd/pubkeys/GM.asc"
    echo "GM GPG key generated."

    # Create 7 Docker sandboxes
    for power in "${POWERS[@]}"; do
      sandbox_name="perfid-${game_id}-$(lowercase "$power")"
      echo "  Creating sandbox: $sandbox_name"
      docker sandbox create "$sandbox_name" claude "$gd" || {
        echo "Warning: failed to create sandbox for $power" >&2
      }
    done

    echo "Game '$game_id' created at $gd"
    echo "Next: perfid bootstrap $game_id"
    ;;

  bootstrap)
    game_id=$(require_game_id "$@")
    gd=$(require_game_exists "$game_id")

    echo "Bootstrapping agents for game '$game_id'..."

    # Import GM public key and generate agent keys (all 7 in parallel)
    agent_pids=()
    agent_powers=()
    for power in "${POWERS[@]}"; do
      sandbox_name="perfid-${game_id}-$(lowercase "$power")"
      echo "  Bootstrapping $power ($sandbox_name)..."

      # Generate bootstrap prompt
      prompt=$(python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from prompt import bootstrap_prompt
print(bootstrap_prompt('$power'))
")

      docker sandbox run "$sandbox_name" -- -p "$prompt" &
      agent_pids+=($!)
      agent_powers+=("$power")
    done
    wait_agents "${agent_pids[@]}" -- "${agent_powers[@]}"

    echo "Bootstrap complete. Agents should have published keys to $gd/pubkeys/"
    echo "Next: perfid play $game_id"
    ;;

  play)
    game_id=$(require_game_id "$@")
    gd=$(require_game_exists "$game_id")

    echo "Starting game loop for '$game_id'..."

    # Main game loop: negotiate → orders → adjudicate → repeat
    while true; do
      # Load current state
      phase_info=$(python3 -c "
import sys, json
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import load_state, get_phase, Phase, format_status
state = load_state('$gd')
phase = get_phase(state)
print(json.dumps({
    'phase': state['phase'],
    'year': state['year'],
    'winner': state['winner'],
    'eliminated': state['eliminated'],
}))
")

      phase=$(echo "$phase_info" | python3 -c "import sys,json; print(json.load(sys.stdin)['phase'])")
      year=$(echo "$phase_info" | python3 -c "import sys,json; print(json.load(sys.stdin)['year'])")
      winner=$(echo "$phase_info" | python3 -c "import sys,json; print(json.load(sys.stdin)['winner'])")

      # Check for winner
      if [[ "$winner" != "None" ]] && [[ "$winner" != "null" ]]; then
        echo ""
        echo "=========================================="
        echo "  GAME OVER — $winner wins!"
        echo "=========================================="
        python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import load_state, format_status
print(format_status(load_state('$gd')))
"
        break
      fi

      echo ""
      echo "--- $year $phase ---"

      # Log phase start
      python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from logger import GameLogger
logger = GameLogger('$gd')
phase = '$phase'
season = phase.split()[0]
phase_type = ' '.join(phase.split()[1:])
logger.phase_start($year, season, phase_type)
"

      case "$phase" in
        "Spring Diplomacy"|"Fall Diplomacy")
          # Negotiation rounds — agents run in parallel within each round
          for round_num in $(seq 1 "$NEGOTIATION_ROUNDS"); do
            echo "  Negotiation round $round_num/$NEGOTIATION_ROUNDS"
            agent_pids=()
            agent_powers=()
            for power in "${POWERS[@]}"; do
              # Skip eliminated powers
              is_eliminated=$(echo "$phase_info" | python3 -c "
import sys,json
info = json.load(sys.stdin)
print('$power' in info['eliminated'])
")
              [[ "$is_eliminated" == "True" ]] && continue

              sandbox_name="perfid-${game_id}-$(lowercase "$power")"
              prompt=$(python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import load_state
from prompt import turn_context
state = load_state('$gd')
print(turn_context('$power', state, '$gd', $round_num, $NEGOTIATION_ROUNDS))
")
              echo "    $power negotiating..."
              docker sandbox run "$sandbox_name" -- -p "$prompt" 2>/dev/null &
              agent_pids+=($!)
              agent_powers+=("$power")
            done
            wait_agents "${agent_pids[@]}" -- "${agent_powers[@]}"

            # Route messages after each round
            python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from message_router import route_messages
route_messages('$gd')
"
          done

          # Advance to movement phase
          python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import load_state, next_phase, save_state
state = load_state('$gd')
state = next_phase(state)
save_state(state, '$gd')
"
          ;;

        "Spring Movement"|"Fall Movement")
          # Collect orders from agents (all in parallel)
          agent_pids=()
          agent_powers=()
          for power in "${POWERS[@]}"; do
            is_eliminated=$(echo "$phase_info" | python3 -c "
import sys,json
info = json.load(sys.stdin)
print('$power' in info['eliminated'])
")
            [[ "$is_eliminated" == "True" ]] && continue

            sandbox_name="perfid-${game_id}-$(lowercase "$power")"
            prompt=$(python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import load_state
from prompt import turn_context
state = load_state('$gd')
print(turn_context('$power', state, '$gd'))
")
            echo "  $power submitting orders..."
            docker sandbox run "$sandbox_name" -- -p "$prompt" 2>/dev/null &
            agent_pids+=($!)
            agent_powers+=("$power")
          done
          wait_agents "${agent_pids[@]}" -- "${agent_powers[@]}"

          # Collect, validate, and adjudicate via jDip
          echo "  Adjudicating via jDip..."
          python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import load_state, adjudicate, save_state, format_status
from orders import collect_orders
from logger import GameLogger

state = load_state('$gd')
gm_gpg = '$gd/gm-gpg'

collected = collect_orders('$gd', state['year'], state['phase'], gm_gpg, state)
all_orders = collected['orders']

if collected['defaults']:
    print(f\"  Default orders for: {', '.join(collected['defaults'])}\")
if collected['errors']:
    for power, errs in collected['errors'].items():
        for order, msg in errs:
            print(f\"  {power} order error: {order} — {msg}\")

# Log submitted orders
logger = GameLogger('$gd')
for power, orders in all_orders.items():
    logger.orders_submitted(power, orders, state['phase'])

# Adjudicate via jDip
state = adjudicate(state, all_orders, '$gd')

# Log results
logger.adjudication_result(state['phase'], [])

print(f\"  Phase advanced to: {state['year']} {state['phase']}\")
"
          ;;

        "Spring Retreat"|"Fall Retreat")
          # Collect retreat orders from agents with dislodged units (all in parallel)
          agent_pids=()
          agent_powers=()
          for power in "${POWERS[@]}"; do
            is_eliminated=$(echo "$phase_info" | python3 -c "
import sys,json
info = json.load(sys.stdin)
print('$power' in info['eliminated'])
")
            [[ "$is_eliminated" == "True" ]] && continue

            sandbox_name="perfid-${game_id}-$(lowercase "$power")"
            prompt=$(python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import load_state
from prompt import turn_context
state = load_state('$gd')
print(turn_context('$power', state, '$gd'))
")
            echo "  $power submitting retreats..."
            docker sandbox run "$sandbox_name" -- -p "$prompt" 2>/dev/null &
            agent_pids+=($!)
            agent_powers+=("$power")
          done
          wait_agents "${agent_pids[@]}" -- "${agent_powers[@]}"

          # Apply retreats and advance phase
          python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import load_state, apply_retreats, next_phase, save_state
from orders import collect_orders

state = load_state('$gd')
gm_gpg = '$gd/gm-gpg'

# For retreat phases, default is disband
collected = collect_orders('$gd', state['year'], state['phase'], gm_gpg, state)

# Apply retreat orders (simplified — agents submit via encrypted files)
dislodged = state.get('dislodged', [])
retreat_orders = []
for d in dislodged:
    power = d['power']
    power_orders = collected['orders'].get(power, [])
    # Parse retreat orders for this dislodged unit
    applied = False
    for o in power_orders:
        parts = o.split()
        if len(parts) >= 4 and parts[2] == '-':
            retreat_orders.append({
                'power': power,
                'unit': d['unit'],
                'action': 'retreat',
                'destination': ' '.join(parts[3:]),
            })
            applied = True
            break
    if not applied:
        retreat_orders.append({
            'power': power,
            'unit': d['unit'],
            'action': 'disband',
        })

state = apply_retreats(state, retreat_orders, '$gd')
state = next_phase(state)
save_state(state, '$gd')
print(f\"  Phase advanced to: {state['year']} {state['phase']}\")
"
          ;;

        "Winter Adjustment")
          # Collect adjustment orders from agents (all in parallel)
          agent_pids=()
          agent_powers=()
          for power in "${POWERS[@]}"; do
            is_eliminated=$(echo "$phase_info" | python3 -c "
import sys,json
info = json.load(sys.stdin)
print('$power' in info['eliminated'])
")
            [[ "$is_eliminated" == "True" ]] && continue

            sandbox_name="perfid-${game_id}-$(lowercase "$power")"
            prompt=$(python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import load_state
from prompt import turn_context
state = load_state('$gd')
print(turn_context('$power', state, '$gd'))
")
            echo "  $power submitting adjustments..."
            docker sandbox run "$sandbox_name" -- -p "$prompt" 2>/dev/null &
            agent_pids+=($!)
            agent_powers+=("$power")
          done
          wait_agents "${agent_pids[@]}" -- "${agent_powers[@]}"

          # Apply adjustments and advance to next year
          python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import (
    load_state, apply_adjustments, next_phase,
    save_state, adjustment_counts, format_status,
)
from orders import collect_orders

state = load_state('$gd')
gm_gpg = '$gd/gm-gpg'

adj_counts = adjustment_counts(state)
collected = collect_orders('$gd', state['year'], state['phase'], gm_gpg, state)

adjustments = {}
for power, count in adj_counts.items():
    if count == 0:
        continue
    power_orders = collected['orders'].get(power, [])
    actions = []
    for o in power_orders:
        parts = o.split()
        if 'Build' in o or 'build' in o:
            # Parse build: 'Build A Paris' or 'Build F Brest'
            unit_type = 'Army' if parts[1].upper() in ('A', 'ARMY') else 'Fleet'
            location = ' '.join(parts[2:])
            actions.append({
                'action': 'build',
                'unit': {'type': unit_type, 'location': location},
            })
        elif 'Disband' in o or 'disband' in o or 'Remove' in o or 'remove' in o:
            unit_type = 'Army' if parts[1].upper() in ('A', 'ARMY') else 'Fleet'
            location = ' '.join(parts[2:])
            actions.append({
                'action': 'disband',
                'unit': {'type': unit_type, 'location': location},
            })
    if actions:
        adjustments[power] = actions

state = apply_adjustments(state, adjustments, '$gd')
state = next_phase(state)
save_state(state, '$gd')

print(format_status(state))
print(f\"  Next year: {state['year']} {state['phase']}\")
"
          ;;

        *)
          echo "Error: unexpected phase '$phase'" >&2
          exit 1
          ;;
      esac

      # Archive messages after each phase
      python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from message_router import archive_phase
archive_phase('$gd', $year, '$(echo "$phase" | tr ' ' '_')')
" 2>/dev/null || true

    done
    ;;

  status)
    game_id=$(require_game_id "$@")
    gd=$(require_game_exists "$game_id")

    python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from game_state import load_state, format_status
state = load_state('$gd')
print(format_status(state))
"
    ;;

  destroy)
    game_id=$(require_game_id "$@")
    gd=$(require_game_exists "$game_id")

    echo "Destroying game '$game_id'..."

    # Tear down Docker sandboxes
    for power in "${POWERS[@]}"; do
      sandbox_name="perfid-${game_id}-$(lowercase "$power")"
      echo "  Removing sandbox: $sandbox_name"
      docker sandbox rm "$sandbox_name" 2>/dev/null || true
    done

    # Optionally remove game directory
    if [[ -d "$gd" ]]; then
      printf "Delete game directory %s? [y/N] " "$gd"
      read -r answer
      if [[ "$answer" =~ ^[Yy]$ ]]; then
        rm -rf "$gd"
        echo "Game directory deleted."
      else
        echo "Game directory kept at $gd"
      fi
    fi

    echo "Game '$game_id' destroyed."
    ;;

  *)
    usage
    ;;
esac
